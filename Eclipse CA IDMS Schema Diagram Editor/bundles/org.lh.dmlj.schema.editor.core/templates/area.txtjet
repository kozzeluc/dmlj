<%
/**
 * Copyright (C) 2015  Luc Hermans
 * 
 * This program is free software: you can redistribute it and/or modify it under the terms of the
 * GNU General Public License as published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with this program.  If
 * not, see <http://www.gnu.org/licenses/>.
 * 
 * Contact information: kozzeluc@gmail.com.
 */
%>
<%@ jet package="org.lh.dmlj.schema.editor.template" imports="org.lh.dmlj.schema.* java.util.*" class="AreaTemplate"%>
<%

/*
This template will generate an area's DDL syntax.
*/

Object[] args = ((List<?>) argument).toArray();
SchemaArea area = (SchemaArea) args[0];
@SuppressWarnings("unused")
boolean sortSchemaEntities = ((Boolean) args[1]).booleanValue();

Map<String, List<String>> subareas = new LinkedHashMap<>();
Map<String, List<String>> displacements = new LinkedHashMap<>();
Map<String, List<String>> indexes = new LinkedHashMap<>();
for (AreaSpecification areaSpecification : area.getAreaSpecifications()) {
	String symbolic = areaSpecification.getSymbolicSubareaName();
	if (symbolic != null) {
		List<String> entities;
		if (subareas.containsKey(symbolic)) {
			entities = subareas.get(symbolic);
		} else {
		    entities = new ArrayList<>();
		    subareas.put(symbolic, entities);
		}
		String p;
		if (areaSpecification.getRecord() != null) {
			p = "RECORD " + areaSpecification.getRecord().getName();
		} else {
		    // todo: make sure the following matches what's generated by the
		    // real IDMS/DB Schema compiler because it probably isn't now		    
		    p = "SET " + areaSpecification.getSystemOwner().getSet().getName();
		}
		entities.add(p);
		Collections.sort(entities); // records first, then sets !
	}
	if (areaSpecification.getRecord() != null &&
		areaSpecification.getRecord().getViaSpecification() != null) {
		
		symbolic = areaSpecification.getRecord()
					 			    .getViaSpecification()
							 		.getSymbolicDisplacementName();
		if (symbolic != null) {
			List<String> records;
			if (displacements.containsKey(symbolic)) {
				records = displacements.get(symbolic);
			} else {
		   		records = new ArrayList<>();
		    	displacements.put(symbolic, records);
			}
			records.add(areaSpecification.getRecord().getName());
			Collections.sort(records);
		}
	}
	if (areaSpecification.getRecord() != null) {
		for (OwnerRole owner : areaSpecification.getRecord().getOwnerRoles()) {
			if (owner.getSet().getMode() == SetMode.INDEXED) {
				IndexedSetModeSpecification isms = 
					owner.getSet().getIndexedSetModeSpecification();
				if (isms.getSymbolicIndexName() != null) {
					List<String> sets;
					if (indexes.containsKey(isms.getSymbolicIndexName())) {
						sets = displacements.get(isms.getSymbolicIndexName());
					} else {
		   				sets = new ArrayList<>();
		    			indexes.put(isms.getSymbolicIndexName(), sets);
					}
					sets.add(owner.getSet().getName());
					Collections.sort(sets);
				}	
			}
		}
	} else {
		IndexedSetModeSpecification isms = 
			areaSpecification.getSystemOwner().getSet().getIndexedSetModeSpecification();
		if (isms.getSymbolicIndexName() != null) {
		    List<String> sets;
			if (indexes.containsKey(isms.getSymbolicIndexName())) {
				sets = displacements.get(isms.getSymbolicIndexName());
			} else {
   				sets = new ArrayList<>();
    			indexes.put(isms.getSymbolicIndexName(), sets);
			}
			sets.add(areaSpecification.getSystemOwner().getSet().getName());
			Collections.sort(sets);
		}			
	}
}
%>
     ADD
     AREA NAME IS <%= area.getName() %>
         ESTIMATED PAGES ARE 0
<%
List<String> symbolicSubareaNames = new ArrayList<>(subareas.keySet()); 
Collections.sort(symbolicSubareaNames);
for (String symbolicSA : symbolicSubareaNames) {
%>         
*+       SUBAREA <%= symbolicSA %> 
<% 
    for (String recordOrSystemOwner : subareas.get(symbolicSA)) {
%>              
*+           USED BY <%= recordOrSystemOwner %>
<%
    }
}
List<String> symbolicDisplacementNames = new ArrayList<>(displacements.keySet());
Collections.sort(symbolicDisplacementNames);
for (String symbolicD : symbolicDisplacementNames) {
%>
*+       SYMBOLIC DISPLACEMENT <%= symbolicD %>
<%
    for (String recordName : displacements.get(symbolicD)) {
%> 
*+           USED BY RECORD <%= recordName %>
<%
	}
}
List<String> symbolicIndexNames = new ArrayList<>(indexes.keySet());
Collections.sort(symbolicIndexNames);
for (String symbolicI : symbolicIndexNames) {
%>
*+       SYMBOLIC INDEX <%= symbolicI %>
<%
    for (String setName : indexes.get(symbolicI)) {
%>  
*+           USED BY SET <%= setName %>
<%
	}
}
%>
<%
for (AreaProcedureCallSpecification callSpec : area.getProcedures()) {
    String p = callSpec.getFunction() == AreaProcedureCallFunction.EVERY_DML_FUNCTION ?
               "" : callSpec.getFunction().toString();
%>
         CALL <%= callSpec.getProcedure().getName() %> <%= callSpec.getCallTime().toString().replaceAll("_", " ") %> <%= p %>
<%
}
%>
         .         