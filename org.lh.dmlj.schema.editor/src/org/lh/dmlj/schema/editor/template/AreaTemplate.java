package org.lh.dmlj.schema.editor.template;

import org.lh.dmlj.schema.*;
import java.util.*;

public class AreaTemplate
{
  protected static String nl;
  public static synchronized AreaTemplate create(String lineSeparator)
  {
    nl = lineSeparator;
    AreaTemplate result = new AreaTemplate();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = "     ADD" + NL + "     AREA NAME IS ";
  protected final String TEXT_2 = NL + "         ESTIMATED PAGES ARE 0";
  protected final String TEXT_3 = NL + "         CALL ";
  protected final String TEXT_4 = " ";
  protected final String TEXT_5 = " ";
  protected final String TEXT_6 = "         " + NL + "*+       SUBAREA ";
  protected final String TEXT_7 = " ";
  protected final String TEXT_8 = "              " + NL + "*+           USED BY ";
  protected final String TEXT_9 = NL + "*+       SYMBOLIC DISPLACEMENT ";
  protected final String TEXT_10 = " " + NL + "*+           USED BY RECORD ";
  protected final String TEXT_11 = NL + "*+       SYMBOLIC INDEX ";
  protected final String TEXT_12 = "  " + NL + "*+           USED BY SET ";
  protected final String TEXT_13 = NL + "         .         ";

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
    
/**
 * Copyright (C) 2013  Luc Hermans
 * 
 * This program is free software: you can redistribute it and/or modify it under the terms of the
 * GNU General Public License as published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with this program.  If
 * not, see <http://www.gnu.org/licenses/>.
 * 
 * Contact information: kozzeluc@gmail.com.
 */

    

/*
This template will generate an area's DDL syntax.
*/
SchemaArea area = (SchemaArea)argument;
Map<String, List<String>> subareas = new LinkedHashMap<>();
Map<String, List<String>> displacements = new LinkedHashMap<>();
Map<String, List<String>> indexes = new LinkedHashMap<>();
for (AreaSpecification areaSpecification : area.getAreaSpecifications()) {
	String symbolic = areaSpecification.getSymbolicSubareaName();
	if (symbolic != null) {
		List<String> entities;
		if (subareas.containsKey(symbolic)) {
			entities = subareas.get(symbolic);
		} else {
		    entities = new ArrayList<>();
		    subareas.put(symbolic, entities);
		}
		String p;
		if (areaSpecification.getRecord() != null) {
			p = "RECORD " + areaSpecification.getRecord().getName();
		} else {
		    // todo: make sure the following matches what's generated by the
		    // real IDMS/DB Schema compiler because it probably isn't now		    
		    p = "SET " + areaSpecification.getSystemOwner().getSet().getName();
		}
		entities.add(p);
		Collections.sort(entities); // records first, then sets !
	}
	if (areaSpecification.getRecord() != null &&
		areaSpecification.getRecord().getViaSpecification() != null) {
		
		symbolic = areaSpecification.getRecord()
					 			    .getViaSpecification()
							 		.getSymbolicDisplacementName();
		if (symbolic != null) {
			List<String> records;
			if (displacements.containsKey(symbolic)) {
				records = displacements.get(symbolic);
			} else {
		   		records = new ArrayList<>();
		    	displacements.put(symbolic, records);
			}
			records.add(areaSpecification.getRecord().getName());
			Collections.sort(records);
		}
	}
	if (areaSpecification.getRecord() != null) {
		for (OwnerRole owner : areaSpecification.getRecord().getOwnerRoles()) {
			if (owner.getSet().getMode() == SetMode.INDEXED) {
				IndexedSetModeSpecification isms = 
					owner.getSet().getIndexedSetModeSpecification();
				if (isms.getSymbolicIndexName() != null) {
					List<String> sets;
					if (indexes.containsKey(isms.getSymbolicIndexName())) {
						sets = displacements.get(isms.getSymbolicIndexName());
					} else {
		   				sets = new ArrayList<>();
		    			indexes.put(isms.getSymbolicIndexName(), sets);
					}
					sets.add(owner.getSet().getName());
					Collections.sort(sets);
				}	
			}
		}
	} else {
		IndexedSetModeSpecification isms = 
			areaSpecification.getSystemOwner().getSet().getIndexedSetModeSpecification();
		if (isms.getSymbolicIndexName() != null) {
		    List<String> sets;
			if (indexes.containsKey(isms.getSymbolicIndexName())) {
				sets = displacements.get(isms.getSymbolicIndexName());
			} else {
   				sets = new ArrayList<>();
    			indexes.put(isms.getSymbolicIndexName(), sets);
			}
			sets.add(areaSpecification.getSystemOwner().getSet().getName());
			Collections.sort(sets);
		}			
	}
}

    stringBuffer.append(TEXT_1);
    stringBuffer.append( area.getName() );
    stringBuffer.append(TEXT_2);
    
for (AreaProcedureCallSpecification callSpec : area.getProcedures()) {
    String p = callSpec.getFunction() == AreaProcedureCallFunction.EVERY_DML_FUNCTION ?
               "" : callSpec.getFunction().toString();

    stringBuffer.append(TEXT_3);
    stringBuffer.append( callSpec.getProcedure().getName() );
    stringBuffer.append(TEXT_4);
    stringBuffer.append( callSpec.getCallTime().toString().replaceAll("_", " ") );
    stringBuffer.append(TEXT_5);
    stringBuffer.append( p );
    
}

     
for (String symbolicSA : subareas.keySet()) {

    stringBuffer.append(TEXT_6);
    stringBuffer.append( symbolicSA );
    stringBuffer.append(TEXT_7);
     
    for (String recordOrSystemOwner : subareas.get(symbolicSA)) {

    stringBuffer.append(TEXT_8);
    stringBuffer.append( recordOrSystemOwner );
    
    }
}
for (String symbolicD : displacements.keySet()) {

    stringBuffer.append(TEXT_9);
    stringBuffer.append( symbolicD );
    
    for (String recordName : displacements.get(symbolicD)) {

    stringBuffer.append(TEXT_10);
    stringBuffer.append( recordName );
    
	}
}
for (String symbolicI : indexes.keySet()) {

    stringBuffer.append(TEXT_11);
    stringBuffer.append( symbolicI );
    
    for (String setName : indexes.get(symbolicI)) {

    stringBuffer.append(TEXT_12);
    stringBuffer.append( setName );
    
	}
}

    stringBuffer.append(TEXT_13);
    return stringBuffer.toString();
  }
}
