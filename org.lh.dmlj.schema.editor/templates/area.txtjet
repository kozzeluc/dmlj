<%@ jet package="org.lh.dmlj.schema.editor.template" imports="org.lh.dmlj.schema.* java.util.*" class="AreaTemplate"%>
<%

/*
This template will generate an area's DDL syntax.
*/
SchemaArea area = (SchemaArea)argument;
Map<String, List<String>> subareas = new LinkedHashMap<>();
Map<String, List<String>> displacements = new LinkedHashMap<>();
Map<String, List<String>> indexes = new LinkedHashMap<>();
for (AreaSpecification areaSpecification : area.getAreaSpecifications()) {
	String symbolic = areaSpecification.getSymbolicSubareaName();
	if (symbolic != null) {
		List<String> entities;
		if (subareas.containsKey(symbolic)) {
			entities = subareas.get(symbolic);
		} else {
		    entities = new ArrayList<>();
		    subareas.put(symbolic, entities);
		}
		String p;
		if (areaSpecification.getRecord() != null) {
			p = "RECORD " + areaSpecification.getRecord().getName();
		} else {
		    // todo: make sure the following matches what's generated by the
		    // real IDMS/DB Schema compiler because it probably isn't now		    
		    p = "SET " + areaSpecification.getSystemOwner().getSet().getName();
		}
		entities.add(p);
		Collections.sort(entities); // records first, then sets !
	}
	if (areaSpecification.getRecord() != null &&
		areaSpecification.getRecord().getViaSpecification() != null) {
		
		symbolic = areaSpecification.getRecord()
					 			    .getViaSpecification()
							 		.getSymbolicDisplacementName();
		if (symbolic != null) {
			List<String> records;
			if (displacements.containsKey(symbolic)) {
				records = displacements.get(symbolic);
			} else {
		   		records = new ArrayList<>();
		    	displacements.put(symbolic, records);
			}
			records.add(areaSpecification.getRecord().getName());
			Collections.sort(records);
		}
	}
	if (areaSpecification.getRecord() != null) {
		for (OwnerRole owner : areaSpecification.getRecord().getOwnerRoles()) {
			if (owner.getSet().getMode() == SetMode.INDEXED) {
				IndexedSetModeSpecification isms = 
					owner.getSet().getIndexedSetModeSpecification();
				if (isms.getSymbolicIndexName() != null) {
					List<String> sets;
					if (indexes.containsKey(isms.getSymbolicIndexName())) {
						sets = displacements.get(isms.getSymbolicIndexName());
					} else {
		   				sets = new ArrayList<>();
		    			indexes.put(isms.getSymbolicIndexName(), sets);
					}
					sets.add(owner.getSet().getName());
					Collections.sort(sets);
				}	
			}
		}
	} else {
		IndexedSetModeSpecification isms = 
			areaSpecification.getSystemOwner().getSet().getIndexedSetModeSpecification();
		if (isms.getSymbolicIndexName() != null) {
		    List<String> sets;
			if (indexes.containsKey(isms.getSymbolicIndexName())) {
				sets = displacements.get(isms.getSymbolicIndexName());
			} else {
   				sets = new ArrayList<>();
    			indexes.put(isms.getSymbolicIndexName(), sets);
			}
			sets.add(areaSpecification.getSystemOwner().getSet().getName());
			Collections.sort(sets);
		}			
	}
}
%>
     ADD
     AREA NAME IS <%= area.getName() %>
         ESTIMATED PAGES ARE 0
<% 
for (String symbolicSA : subareas.keySet()) {
%>         
*+       SUBAREA <%= symbolicSA %> 
<% 
    for (String recordOrSystemOwner : subareas.get(symbolicSA)) {
%>              
*+           USED BY <%= recordOrSystemOwner %>
<%
    }
}
for (String symbolicD : displacements.keySet()) {
%>
*+       SYMBOLIC DISPLACEMENT <%= symbolicD %>
<%
    for (String recordName : displacements.get(symbolicD)) {
%> 
*+           USED BY RECORD <%= recordName %>
<%
	}
}
for (String symbolicI : indexes.keySet()) {
%>
*+       SYMBOLIC INDEX <%= symbolicI %>
<%
    for (String setName : indexes.get(symbolicI)) {
%>  
*+           USED BY SET <%= setName %>
<%
	}
}
%>
         .         